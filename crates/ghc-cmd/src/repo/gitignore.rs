//! `ghc repo gitignore` sub-commands.

use anyhow::{Context, Result, bail};
use clap::{Args, Subcommand};
use serde::Deserialize;

use ghc_core::ios_println;

use crate::factory::Factory;

/// List and view available repository gitignore templates.
#[derive(Debug, Subcommand)]
pub enum GitignoreCommand {
    /// List available repository gitignore templates.
    List(ListArgs),
    /// View a specific gitignore template.
    View(ViewArgs),
}

impl GitignoreCommand {
    /// Run the sub-command.
    ///
    /// # Errors
    ///
    /// Returns an error if the command fails.
    pub async fn run(&self, factory: &Factory) -> Result<()> {
        match self {
            Self::List(args) => args.run(factory).await,
            Self::View(args) => args.run(factory).await,
        }
    }
}

// ---------------------------------------------------------------------------
// gitignore list
// ---------------------------------------------------------------------------

/// List available repository gitignore templates.
#[derive(Debug, Args)]
pub struct ListArgs;

impl ListArgs {
    async fn run(&self, factory: &Factory) -> Result<()> {
        let client = factory.api_client("github.com")?;
        let ios = &factory.io;
        let cs = ios.color_scheme();

        let templates: Vec<String> = client
            .rest(reqwest::Method::GET, "gitignore/templates", None)
            .await
            .context("failed to list gitignore templates")?;

        if templates.is_empty() {
            bail!("no gitignore templates found");
        }

        ios_println!(ios, "{}", cs.bold("GITIGNORE"));

        for tmpl in &templates {
            ios_println!(ios, "{tmpl}");
        }

        Ok(())
    }
}

// ---------------------------------------------------------------------------
// gitignore view
// ---------------------------------------------------------------------------

/// View a specific gitignore template.
///
/// `<template>` is a case-sensitive `.gitignore` template name.
/// For a list of available templates, run `ghc repo gitignore list`.
#[derive(Debug, Args)]
pub struct ViewArgs {
    /// Template name (case-sensitive, e.g., "Go", "Python", "Rust").
    #[arg(value_name = "TEMPLATE")]
    template: String,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct GitIgnoreTemplate {
    name: String,
    source: String,
}

impl ViewArgs {
    async fn run(&self, factory: &Factory) -> Result<()> {
        let client = factory.api_client("github.com")?;
        let ios = &factory.io;

        let path = format!("gitignore/templates/{}", self.template);
        let result: Result<GitIgnoreTemplate, _> =
            client.rest(reqwest::Method::GET, &path, None).await;

        match result {
            Ok(gi) => {
                if ios.is_stdout_tty() {
                    ios_println!(ios, "");
                }
                ios_println!(ios, "{}", gi.source);
                Ok(())
            }
            Err(ghc_api::errors::ApiError::Http { status: 404, .. }) => {
                bail!(
                    "'{}' is not a valid gitignore template. \
                     Run `ghc repo gitignore list` for options",
                    self.template
                );
            }
            Err(e) => Err(e.into()),
        }
    }
}

#[cfg(test)]
mod tests {
    use serde_json::json;
    use wiremock::matchers::{method, path};
    use wiremock::{Mock, ResponseTemplate};

    use crate::test_helpers::TestHarness;

    use super::*;

    #[tokio::test]
    async fn test_should_list_gitignore_templates() {
        let h = TestHarness::new().await;
        Mock::given(method("GET"))
            .and(path("/gitignore/templates"))
            .respond_with(
                ResponseTemplate::new(200)
                    .set_body_json(json!(["C", "C++", "Go", "Java", "Python", "Rust"])),
            )
            .mount(&h.server)
            .await;

        let args = ListArgs;
        let result = args.run(&h.factory).await;
        assert!(result.is_ok(), "list should succeed: {result:?}");
        let stdout = h.stdout();
        assert!(stdout.contains("Go"));
        assert!(stdout.contains("Rust"));
        assert!(stdout.contains("Python"));
    }

    #[tokio::test]
    async fn test_should_view_gitignore_template() {
        let h = TestHarness::new().await;
        Mock::given(method("GET"))
            .and(path("/gitignore/templates/Rust"))
            .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                "name": "Rust",
                "source": "# Generated by Cargo\n/target/\n"
            })))
            .mount(&h.server)
            .await;

        let args = ViewArgs {
            template: "Rust".into(),
        };
        let result = args.run(&h.factory).await;
        assert!(result.is_ok(), "view should succeed: {result:?}");
        let stdout = h.stdout();
        assert!(stdout.contains("/target/"));
    }

    #[tokio::test]
    async fn test_should_fail_view_unknown_template() {
        let h = TestHarness::new().await;
        Mock::given(method("GET"))
            .and(path("/gitignore/templates/NotALanguage"))
            .respond_with(ResponseTemplate::new(404).set_body_json(json!({
                "message": "Not Found",
                "documentation_url": "https://docs.github.com"
            })))
            .mount(&h.server)
            .await;

        let args = ViewArgs {
            template: "NotALanguage".into(),
        };
        let result = args.run(&h.factory).await;
        assert!(result.is_err());
        let msg = result.unwrap_err().to_string();
        assert!(
            msg.contains("not a valid gitignore template"),
            "unexpected error: {msg}"
        );
    }

    #[tokio::test]
    async fn test_should_fail_list_empty() {
        let h = TestHarness::new().await;
        Mock::given(method("GET"))
            .and(path("/gitignore/templates"))
            .respond_with(ResponseTemplate::new(200).set_body_json(json!([])))
            .mount(&h.server)
            .await;

        let args = ListArgs;
        let result = args.run(&h.factory).await;
        assert!(result.is_err());
        assert!(
            result
                .unwrap_err()
                .to_string()
                .contains("no gitignore templates")
        );
    }
}
